<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>函数的扩展</title>
</head>
<body>
<h3>函数的扩展</h3>
<ol>
    <li>函数的length属性,等于传入的第一个被赋予默认值的参数的index,即(a,b=2,c)等于b的下标1</li>
    <li>函数的length属性,不包括 rest 参数。</li>
    <li>作用域,外层作用域>形参作用域>函数体作用域</li>
    <li>可以将参数默认值设为undefined,表明这个参数是可以省略的。(a = undefined)</li>
    <li>rest 参数之后不能再有其他参数（即只能是最后一个参数）,否则会报错。(...a,b)</li>
    <li>函数参数使用了默认值、解构赋值、或者rest参数,那么函数内部就不能显式设定为严格模式.</li>
</ol>
<h4>箭头函数使用注意点</h4>
<ol>
    <li>函数体内的this对象,总是指向箭头函数定义生效时所在的对象[箭头函数绑定的内部属性],而不是使用时所在的对象.实际上,箭头函数没有this,他的this是上一级函数作用域的this.</li>
    <li>不可以当作构造函数,不可以使用new命令符执行.</li>
    <li>不可以使用arguments对象,应使用rest扩展运算符代替.</li>
    <li>不可以当做Generator函数,不能使用yield命令.</li>
    <li>另外,如果函数体很复杂,不单纯是为了计算值,不应该使用箭头函数.而是要使用普通函数,提高代码可读性.</li>
</ol>
<h4>双冒号运算符[只是提案]</h4>
<ol>
    <li>bar::foo;相当于foo.bind(bar);</li>
    <li>解释:函数绑定运算符是并排的两个冒号（::）,双冒号左边是一个对象,右边是一个函数。该运算符会自动将左边的对象,作为上下文环境（即this对象）,绑定到右边的函数上面。</li>
</ol>
<h4>尾调用优化</h4>
<ol>
    <li>概念:某个函数的最后一步是调用另一个函数</li>
    <li>在函数调用时,会在内存中形成一个'调用记录',又称'调用帧',保存调用位置和内部变量等信息.</li>
    <li>函数调用自身,叫做递归,在函数结尾调用自身,叫做尾递归</li>
    <li>递归非常耗费内存,因为需要同时保存成千上百个调用帧,很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说,由于只存在一个调用帧,所以永远不会发生“栈溢出”错误。</li>
    <li>尾递归的实现,需要把所有用到的内部变量改写成函数的参数</li>
    <li>柯里化:将多参数的函数转化成单参数的函数</li>
</ol>
<p>
    新写法的函数,或者箭头函数，{a(){},b:()=>{})，都不能被new，但是赋值给变量之后可以被new的。
    新写法的函数有自己的this，箭头函数没有自己的this。
</p>
<script src="loadJs.js"></script>
<script>
    loadJs('函数的扩展.js');
</script>
</body>
</html>
