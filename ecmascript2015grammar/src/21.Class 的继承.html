<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Class 的继承</title>
</head>
<body>
<h3>class继承</h3>
<h4>强!无敌!!</h4>
<ol>
    <li>class可以通过extends关键字实现继承.它比es5更清晰,简单,方便.</li>
    <li>super关键字表示父类的构造函数,用来新建父类的this对象.</li>
    <li>子类必须在constructor方法中调用super方法,因为子类的this对象必须先通过父类的构造函数完成塑造,得到父类相同的属性和方法,然后再加上子类的属性和方法.否则无法得到this对象.</li>
    <li>es5的继承,实例先创造子类的this,在将父类的方法添加到this对象.</li>
    <li>es6的继承,先创建父类实例对象的属性和方法,然后添加到this对象,再用子类构造函数修改this.</li>
    <li>这就是说,子类的实例基于父类实例,只要调用super方法后,才能使用this.</li>
    <li>父类的静态方法,也会被子类继承.</li>
</ol>
<h4>Object.getPrototypeOf()</h4>
<ol>
    <li>从子类上获取父类.子类实例的原型是父类实例.</li>
</ol>
<h4>super关键字</h4>
<ol>
    <li>super关键字,既可以当函数使用,也可以当对象使用.</li>
    <li>当作函数调用时,代表父类的构造函数.虽然代表父类构造函数,但父类构造函数的this指向子类的this.</li>
    <li>作为对象时,在普通方法中,指向父类的原型,在静态方法中,指向父类.</li>
    <li>无法通过super调用定义在父类实例上的属性或方法.</li>
    <li>通过super调用父类方法时,父类方法的this指向子类实例.相当于super.a.call(this).</li>
    <li>同理,super调用父类静态方法时,父类静态方法的this指向子类.</li>
    <li>对象都是继承其他对象的,所以可以在任何对象中,使用super关键字.</li>
</ol>
<hr>
<h4>类的 prototype 属性和__proto__属性</h4>
<p class="red">是对于类,不是实例</p>
<ol>
    <li>typeof A === 'function',所以:</li>
    <li>__proto__表示构造函数的继承,总是指向父类.</li>
    <li>prototype.__proto__属性,表示方法的继承,总是指向父类的prototype.</li>
    <li>class B extends A,则B.__proto__ === A;B.prototype.__proto__ === A.prototype.</li>
    <li>class A,则A.__proto__ === Function.prototype;A.prototype.__proto__ === Object.prototype.A作为一个基类,就是一个普通函数,直接继承Function.prototype.</li>
</ol>
<p class="red">对于实例</p>
<ol>
    <li>子类实例的__proto__指向子类的原型对象.</li>
    <li>子类实例的__proto__的__proto__指向父类的原型对象.</li>
</ol>
<h4>原生功能构造函数的继承</h4>
<ol>
    <li>es6允许继承原生构造函数定义子类,因为es6是先新建父类的实例对象this,然后再用子类的构造函数修饰this,使得父类的所有行为可以被继承.</li>
    <li>extends关键字,不仅可以继承类,还可以继承原生的构造函数.</li>
    <li>继承Object的子类,有一个行为差异.一旦Object方法不是通过new Object形式调用,则会忽略参数.</li>
</ol>
<script src="loadJs.js"></script>
<script>
    loadJs('Class 的继承.js');
</script>
</body>
</html>