<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>函数的扩展</title>
</head>
<body>
<p>函数的length属性,等于传入的第一个被赋予默认值的参数的index,即(a,b=2,c)等于b的下标1</p>
<p>函数的length属性，不包括 rest 参数。</p>
<p>作用域,外层作用域>形参作用域>函数体作用域</p>
<p>可以将参数默认值设为undefined，表明这个参数是可以省略的。(a = undefined)</p>
<p>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。(...a,b)</p>
<p>函数形参使用扩展运算符rest,结构,默认值的情况下,函数体内部不能使用'use strict'</p>
<hr>
<h4>箭头函数使用注意点</h4>
<p>1.函数体内的this对象,就是定义时所在的对象,而不是使用时所在的对象.即this关键字所在的上一层函数作用域</p>
<p>2.不可以使用new命令符执行,不可以作构造函数</p>
<p>3.不可以使用arguments对象,应使用rest扩展运算符代替</p>
<p>4.不能使用yield命令,不能用作Generator函数</p>
<p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p>
<hr>
<h4>双冒号运算符</h4>
<p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<p>bar::foo;相当于foo.bind(bar);</p>
<hr>
<h4>尾调用优化</h4>
<p>概念:某个函数的最后一步是调用另一个函数</p>
<p>在函数调用时,会在内存中形成一个'调用记录',又称'调用帧',保存调用位置和内部变量等信息.</p>
<p>函数调用自身,叫做递归,在函数结尾调用自身,叫做尾递归</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<p>尾递归的实现,需要把所有用到的内部变量改写成函数的参数</p>
<p>柯里化:将多参数的函数转化成单参数的函数</p>
<script src="函数的扩展.js"></script>
</body>
</html>
