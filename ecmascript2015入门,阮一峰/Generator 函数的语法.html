<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Generator 函数的语法</title>
</head>
<body>
<h3>基本概念</h3>
<ol>
    <li>Generator提供了一种异步编程的解决方案,分装了多个内部状态.</li>
    <li>执行Generator会返回一个遍历器对象.</li>
    <li>形式上Generator是一个普通函数,function关键字与函数间有个*号,函数体内部使用yield表达式,(yield)产出不同的状态.</li>
</ol>
<h3>执行</h3>
<ol>
    <li>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象,遍历器对象.</li>
    <li>下一步必须调用遍历器对象的next方法,使得指针指向下一个状态.</li>
    <li>每次调用next方法,内部指针就从函数头部或上一次停下来的地方开始执行,直到遇到下一个yield表达式或return语句.</li>
    <li>yield表达式是暂停执行的标记,next方法是恢复执行的方法.</li>
</ol>
<hr>
<h3>yield表达式</h3>
<ol>
    <li>遇到yield表达式,就暂停执行后面的操作,并将跟在yield后面的那个表达式的值作为返回对象的value值.</li>
    <li>只有调用next方法,内部指针指向该语句才会执行,这是手动的惰性求值语法.</li>
    <li>由于通过yield返回了一系列的值,这个函数才被叫做生成器.</li>
</ol>
<p>用法</p>
<ol>
    <li>yield只能在Generator函数中使用.</li>
    <li>如果要在另一个表达式中使用,则必须放在小括号中.</li>
    <li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号.</li>
</ol>
<p>与Iterator接口的关系</p>
<ol>
    <li>由于Generator是遍历器生成函数,因此可以把Generator赋值给对象的Symbol.iterator属性,从而使得该对象具有Iterator接口.</li>
    <li>Generator函数执行返回的 遍历器对象的 Symbol.iterator属性执行后返回这个遍历器对象.</li>
</ol>
<h3>next方法的参数</h3>
<ol>
    <li>yield表达式本身没有返回值,next方法可以带一个参数,改参数就会当做上一个yield表达式的返回值.</li>
    <li>这个功能有很重要的语法意义,Generator函数从暂停状态恢复到运行,它的上下文状态是不变的.</li>
    <li>通过next方法的参数,就有办法在Generator函数开始运行之后,继续向函数体内部注入值.</li>
    <li>也就是说,在Generator函数运行的不同阶段,从外部向内部注入不同的值,从而调整函数行为.</li>
    <li>第一次使用next方法时,传递参数是无效的.因为第一个next方法用来启动遍历器对象.</li>
</ol>
<h3>for...of循环</h3>
<ol>
    <li>for...of可以自动遍历generator生成的iterator对象,不必调用next方法.</li>
    <li class="red">一旦next方法返回的对象的done属性为true,则循环终止,且不包含该返回对象.所以说,遍历不到return 的值.</li>
    <li>扩展运算符...\结构赋值\Array.from方法内部调用的但是遍历器接口.它们都可以讲Generator函数返回的Iterator对象作为参数.</li>
</ol>
<h3>Generator.prototype.throw</h3>
<ol>
    <li>Generator函数返回的遍历器对象都有一个throw方法,可以在函数体外抛出错误,然后在Generator函数体内捕获.</li>
    <li>Generator函数内部的catch捕获过外部实例的throw方法抛出的错误之后,就不会再捕获后面的错误了.</li>
    <li>throw方法可以传递一个参数,被Generator内部的catch语句接收.</li>
    <li>全局throw方法仅能被throw语句捕获,Generator的throw不仅如此,还可以被Generator函数内部的catch捕获</li>
    <li>在抛出错误之前,必须先执行过next方法,才能被Generator内部catch捕获.</li>
    <li>throw方法在被Generator内部捕获之后,会继续执行到下一条yield表达式.</li>
</ol>
<script src="loadJs.js"></script>
<script>
    loadJs('Generator 函数的语法.js');
</script>
</body>
</html>