<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Generator 函数的语法</title>
</head>
<body>
<h3>基本概念</h3>
<ol>
    <li>Generator提供了一种异步编程的解决方案,分装了多个内部状态.</li>
    <li>执行Generator会返回一个遍历器对象.</li>
    <li>形式上Generator是一个普通函数,function关键字与函数间有个*号,函数体内部使用yield表达式,(yield)产出不同的状态.</li>
</ol>
<h3>执行</h3>
<ol>
    <li>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象,遍历器对象.</li>
    <li>下一步必须调用遍历器对象的next方法,使得指针指向下一个状态.</li>
    <li>每次调用next方法,内部指针就从函数头部或上一次停下来的地方开始执行,直到遇到下一个yield表达式或return语句.</li>
    <li>yield表达式是暂停执行的标记,next方法是恢复执行的方法.</li>
</ol>
<hr>
<h3>yield表达式</h3>
<ol>
    <li>遇到yield表达式,就暂停执行后面的操作,并将跟在yield后面的那个表达式的值作为返回对象的value值.</li>
    <li>只有调用next方法,内部指针指向该语句才会执行,这是手动的惰性求值语法.</li>
    <li>由于通过yield返回了一系列的值,这个函数才被叫做生成器.</li>
</ol>
<p>用法</p>
<ol>
    <li>yield只能在Generator函数中使用.</li>
    <li>如果要在另一个表达式中使用,则必须放在小括号中.</li>
    <li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号.</li>
</ol>
<p>与Iterator接口的关系</p>
<ol>
    <li>由于Generator是遍历器生成函数,因此可以把Generator赋值给对象的Symbol.iterator属性,从而使得该对象具有Iterator接口.</li>
    <li>Generator函数执行返回的 遍历器对象的 Symbol.iterator属性执行后返回这个遍历器对象.</li>
</ol>
<h3>next方法的参数</h3>
<ol>
    <li>yield表达式本身没有返回值,next方法可以带一个参数,改参数就会当做上一个yield表达式的返回值.</li>
    <li>这个功能有很重要的语法意义,Generator函数从暂停状态恢复到运行,它的上下文状态是不变的.</li>
    <li>通过next方法的参数,就有办法在Generator函数开始运行之后,继续向函数体内部注入值.</li>
    <li>也就是说,在Generator函数运行的不同阶段,从外部向内部注入不同的值,从而调整函数行为.</li>
    <li>第一次使用next方法时,传递参数是无效的.因为第一个next方法用来启动遍历器对象.</li>
</ol>

<script src="loadJs.js"></script>
<script>
    loadJs('Generator 函数的语法.js');
</script>
</body>
</html>