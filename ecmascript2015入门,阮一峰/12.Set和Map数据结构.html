<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <title>Set和Map数据结构</title>
</head>
<body>
<h3>Set和Map数据结构</h3>
<h4>Set</h4>
<ol>
    <li>类似于数组,但成员的值都是唯一的.</li>
    <li>Set本身是一个构造函数,用来生成Set数据结构.</li>
    <li>实例具有iterator接口.</li>
</ol>
<p>实例属性和方法:</p>
<ol>
    <li>size:相当于数组的length.</li>
    <li>constructor:指向构造函数.</li>
    <li>add:添加某个成员,返回实例.</li>
    <li>delete:删除某个成员,返回布尔值,表示成功还是失败.</li>
    <li>has:是否包含某个成员,返回布尔值.</li>
    <li>clear:删除全部成员.</li>
    <li>实例的遍历操作:keys,values,entries,forEach.</li>
</ol>

<h4>WeakSet</h4>
<ol>
    <li>也是不重复的值的集合.</li>
    <li>WeakSet的成员只能是对象.</li>
    <li>WeakSet中的对象是弱引用,垃圾回收机制可能会回收不用的对象,而不考虑这个对象是否存在于WeakSet中.</li>
    <li>垃圾回收机制依赖引用计数,如果一个值的引用次数不为零,垃圾回收机制就不会释放这块内存.</li>
    <li>结束使用该值之后,垃圾回收机制可能忘记取消引用,导致内存无法释放,进而可能引发内存泄漏.</li>
    <li>WeakSet里面的引用,都不记入垃圾回收机制,所以不存在内存泄漏的问题</li>
    <li>只要这些对象在外部消失,他在WeakSet里面的引用就会自动消失</li>
    <li>由于垃圾回收机制可以回收WeakSet里面的值,而垃圾回收机制何时运行是不确定的,所以WeakSet的值的个数不确定,故不支持遍历</li>
</ol>
<h4>Map</h4>
<ol>
    <li>类似于对象,但传统对象只能用字符作为键,而Map可以以对象作为键</li>
    <li>Object是字符串-值对应,而Map是值-值对应</li>
    <li>只有对同一个对象的引用，Map 结构才将其视为同一个键。</li>
</ol>
<h4>WeakMap</h4>
<ol>
    <li>只接受对象作为键名</li>
    <li>键名指向的对象不计入垃圾回收机制</li>
    <li>以dom元素为键,当这个dom被移除后,这个对应的WeakMap记录也会被清除</li>
    <li>用于未来可能消失的对象,防止内存泄漏</li>
    <li>但对于值来说,还是正常引用</li>
</ol>
<script src="loadJs.js"></script>
<script>
    loadJs('Set和Map数据结构.js');
</script>
</body>
</html>